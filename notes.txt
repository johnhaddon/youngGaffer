ui rules
========

* need to make modifier/button use consistent everywhere
	* ALT will be used purely for camera movement and nothing else
	* the apple/windows keys will not be used

undo/redo
=========

	- how/where do we implement this?
		- what needs to be undoable
			- create/delete of nodes
			- parent/unparent of nodes
			- add/remove of dynamic plugs
			- set/connect of plugs
			- renaming of nodes and plugs
		- where undo needs to work from
			- node tweaker
			- graph editor
			- script editor?
				- trickier

* Undoable class

	* do()
	* undo()
	* script() ??
	
	* CompoundUndoable stores many actions as a single one
	
* UndoList 

* ScriptNode holds an UndoList

	* API commands which must be undoable find the appropriate
	  ScriptNode and add an Undoable object to the CompoundUndable at
	  the top of the UndoList
	  
	* UI actions push a new CompoundUndoable so that whatever actions they
	  take are batched together as one.
* interactive dragging (slider/manipulators) probably doesn't enter an undoable action for every substep, but just
an undoable event on release?

* is it possible to have a singleton undo list, and undo just bits of it nonlinearly?
	* 0 1 2 3 4 5	* undo 1 undoes 54321 and redoes 2345
					* as long as each action has refcounted pointers to the things it operates on this should work?
						* do we even need to unwind and rewind?
							* each undo element will have refcounted pointers to what it needs anyway
								* so even if the objects involved are deleted it'll do the right thing?
									* not really - you could end up connecting things back up to objects which are
									  conceptually deleted. which is an interesting point - how do we delete nodes?
									  	* i thought we could just unparent them, but that's not enough because they'll
										  remain in the undo queue, so connections and wotnot won't be broken
											* we could have del node.child implemented with a __delattr__ method
											  which performs the appropriate disconnections
											* or we could have nodes use a parentChanged callback to remove all connections
											  when they are removed
	* if we can do this then :
		* ctrl-z undoes the last action from the global list
		* shift-ctrl-z undoes the last action local to a particular control

	* is this really desirable?
		* there are plenty of nasty cases
		* will saving node states with each rendered preview give us equivalent functionality cleanly?					

ui implementation
=================

* there must be no gtk in the public api for the ui library

cut + paste
===========

* serialise and read
		
script node
===========

* filename plug
* execute( string pythonCode, bool undoable ??? ) method
	* this is what all ui controls use to perform their work, and this is where the undo queue is
	implemented?????
		* i don't think so anymore
* undo(), redo() methods
* save/load methods

extended node constructors
=========================

* take keyword arguments for setting plugs and connecting things
	* AddNode( op1 = 10, op2 = 20 )
* can implement **kwargs in boost python using the undocumented class_.def_raw method

ui
==

* no menu bar?
	* waste of space
	* context sensitive menus should do
		* really? what is the context for file->open?
			* an empty graph window?
	
* fullscreen mode

* CompoundPlugWidget or GroupPlugWidget or whatever
	* String in label to summarise the state of the contents
		* Customisable with a callback function

* consistency!!!
	* hotkeys + modifiers behave similarly everywhere
	* right click is context sensitive menu
	* ctrl-right click is context sensitive menu to modify the ui
	* middle mouse don't do nuffink
		* cos scroll wheels aren't very clickable
		* maybe the scroll wheel can be used for stuff though

* file path control
	* tab completion
	* ctrl delete removes one path level
	* right click on a path component pops up all other options at that level
		* have submenus based on alphabetic ranges when there are too many options
		  at a level
		* selecting an option changes that component
			* but attempts to keep the following components the same if they exist
				* so you can change to the same directory in a different shot

* float/int control
	* no wasting of space with the rubbish +- buttons on the right
		* up/down cursors increment/decrement the digit to the right of the cursor
	* virtual slider?
	
issues
======

plugs/parameters

	- plug has :
		- connections
		- dependencies?
		- signals
		- connectionValid() method
		
	- wrap parameters in a ParameterPlug?

nodes

	- nodes have :
	
		parent (another node)
		children
		compute
		signals

object naming / identification

	- all objects must have a (unique? - not necessarily - could be useful to have groups) id
	- use for selection, grouping, shader application etc
	- need integers for image based selection?
		- yes. id should be integer.
	- is id a "user:gaffer:id" attribute or a primvar?
		- an attribute. then ids can easily be applied to groups and procedurals.
		- we need Renderer::getAttr to work then.
			- RxAttribute does work for user attributes though
	
time

	- we'd like feedback for non-photoreal shit
	- we'd like dependencies at different times for shadow map generation

proxies

	- should be able to use low res standins but still have shaders work,
		deformers work etc.	

procedurals

	- everything should be a procedural?
	
	- procedurals should be able to operate on procedurals
		- this is where the SceneRenderer comes in
			- not necessarily
				- we could have a GafferProcedural base
					class with a build() method which must return a
					VisibleRenderable, and which is called by doRender()
	  
	- how to determine bounds quickly for deformers and transform caches?
	
referencing 

	- so one person can build a scene and release it as a script
		- and another can bring that in as a single node and apply shading and wotnot afterwards
	- should be implemented as a ScriptNode embedded within the script - so ScriptNodes can 
	  have at least one input and output plug...they'll be like groups but they'll save/load
	  to a separate file...
	
viewer
======

gl layer with hardware shading and shadowing

final render layer

	- with fast tweaking based on secondary output munging
		- possibly without even raising a tweaker window
			- just drag on the image with hotkeys to make a virtual
			  diffuse/spec/whatever slider for the object under the mouse
	- click raises shader editor for object
		- using id pass

norman lighting layer?

lights + shading
================

* basic point, distant, spot and environment bases
* pluggable light components to modify those lights
	* shadows (manipulator for framing etc)
		* light can have many shadows
	* falloff
	* blockers
	* gobos
	* specular reflection card for spotlight
* reflection cards
* a light component may be connected to any number of lights
* how do we do map generation??
* what units do we use for light intensity, diffuse reflectance etc?
	* exposure based?
	* physically accurate?
	* usual nonsense?
	* force reflectances below a sum of 1?
* hdri creation tools needed

features
========

save all shader parameters with each rendered image
	
	- revert
	- mix back
	
parameter value overlays on saved images?

obvious things not to forget
============================

* sideways render
* overscan render (using displaywindow/datawindow difference as an option)
* playblasting

colorspace management
=====================

* need unified colorspace support everywhere

	-	gtk representations of color
	-	gl representations of color
		-	imager shader? append code onto other shaders as they're compiled?
	-	image transforms
	
* implement as cube luts? then can work anywhere easily

display drivers
===============

* define a DisplayDriver interface class which is prettier than that DSpy nonsense
	* simple
	* force floats for everything? or do ints need support?
* implement DSpy * in terms of that
* implement a SocketDisplayDriver
	* can talk to any other DisplayDriver on the other side
* implement an exr driver with sideways rerotate and checkpointing

geometry support
================

* polys/subdees
	* done already
* nurbs
	* need IECoreMaya export support
* curves
	* need IECore and IECoreMaya support
* spheres, disks etc
	* need IECore support
* blobbies
	* need IECore support
* hierarchical subdees
	* hold off for the moment

64 bit
======

* should start testing a 64 bit version as soon as possible
	* buy a cheap ass box and shove centos on it?

packaging
=========

* need build script to package up a version for release/distribution
	* have a build setup which builds everything from scratch
			
* include python and all modules within the package
* precompile .py files into .pyc
* keep mac package in the unix style for the moment
* potential layout

	- gaffer
		bin
			gaffer 	- tcsh script
					- somehow this launches some python for each app - possibly like do?
		python
			# could we just merge these in with the main directories?
			# or is it best to keep it very separate?
				- I SAY MERGE 'EM!
			bin
			lib
				python2.5
					site-packages
						pygtk
						IECore
						...
						GafferUI
		lib
			libIECore
			...
			libGafferUI
		include
			IECore
			...
			GafferUI
		test
			# why not distribute the unit tests?
			# why not have 'em as python modules in the python directory though?
			IECore
			..
			GafferUI

basic timeline
==============

stage one :

signals
nodes/plugs
graph ui
tweaker ui
script editor ui
read node
renderer node
viewer node
write node

stage two :

lights
manipulators
deformers (vertcache)
image based id selection
scenes/transforms
shader assignment
shadow map generation
primvars/per object shader tweaks
expressions
shader library

stage three :

hardware shaders
light linking
trace sets
pointcloud generation (within graph)

nagging problems
================

* incompatibilities between tiff library in /opt/local/lib and the one in the ImageIO framework

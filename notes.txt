
undo/redo
=========

	- how/where do we implement this?
		- what needs to be undoable
			- create/delete of nodes
			- parent/unparent of nodes
			- add/remove of dynamic plugs
			- set/connect of plugs
			- renaming of nodes and plugs
		- where undo needs to work from
			- node tweaker
			- graph editor
			- script editor?
				- trickier

* Command class or built into C++ API?

	* 	Command (Action? Doable?) class
		- then non undoable things don't become undo actions
			- like the addition of static plugs to a node
		- bindings use the command class to do their work
		
	* 	If we want everything to be echoable through the script editor
		then commands must be implemented via ScriptNode::execute?
		
		*	Or just echo the script equivalent while doing it via C++?
		
	*	If we want scripting to be undoable then the bindings must use
		Commands
		
		* This makes an infinite loop if Commands are implemented via
		  the ScriptNode::execute
		  
		  	* Unless either :
			
				* ScriptNode::execute takes a "bool undoable" argument
					
					-	and this is somehow reflected in the bindings
					
				or :
				
				* Command class just echoes the script equivalent of what
				  it does and actually uses C++ for the work
				  
				  	-	but that means a doubling of implementation work,
						and the potential for bugs

* would be beautiful to see every action taken using the ui go through the script editor.
	* regardless of how we implement undo
* this single point of execution could then implement the undo layer too. is probably pretty doable to make an execution context
(a locals dictionary) that gives exactly the same api as the bindings but implements everything with an undo stack
behind the scenes. this would be awesome - scripts could run with or without undo just by giving them different
contexts.
	* or we implement that in the standard bindings
		* but then you can't write c++ stuff which is undoable
* interactive dragging (slider/manipulators) probably doesn't enter an undoable action for every substep, but just
an undoable event on release?
* we need to batch a series of events into a single undo action (e.g. the results of a script execution)
* either that or we implement undo as a core part of the api anyway  - setValue, setInput, rename, addChild etc
all take some undoContext that they place undo/redo commands into
	* they probably find the undo context by finding their parent script node
		* they shouldn't be passed the undo context, as different actions can't
		  be put into different undo contexts - it would cause havoc
		* which is where the undo context is?
			* or is there one undo context for everything?
				* how do you reparent nodes into one script from another?
					* can't undo in one script but not the other
						* maybe can't move node from one script to another?
	* is undo way easier to implement in python though?
* is it possible to have a singleton undo list, and undo just bits of it nonlinearly?
	* 0 1 2 3 4 5	* undo 1 undoes 54321 and redoes 2345
					* as long as each action has refcounted pointers to the things it operates on this should work?
						* do we even need to unwind and rewind?
							* each undo element will have refcounted pointers to what it needs anyway
								* so even if the objects involved are deleted it'll do the right thing?
									* not really - you could end up connecting things back up to objects which are
									  conceptually deleted. which is an interesting point - how do we delete nodes?
									  	* i thought we could just unparent them, but that's not enough because they'll
										  remain in the undo queue, so connections and wotnot won't be broken
											* we could have del node.child implemented with a __delattr__ method
											  which performs the appropriate disconnections
	* if we can do this then :
		* ctrl-z undoes the last action from the global list
		* shift-ctrl-z undoes the last action local to a particular control

	* is this really desirable?
		* there are plenty of nasty cases
		* will saving node states with each rendered preview give us equivalent functionality cleanly?					

ui implementation
=================

* there must be no gtk in the public api for the ui library

cut + paste
===========

* serialise and read
		
script node
===========

* filename plug
* execute( string pythonCode, bool undoable ??? ) method
	* this is what all ui controls use to perform their work, and this is where the undo queue is
	implemented?????
		* i don't think so anymore
* undo(), redo() methods
* save/load methods

extended node constructors
=========================

* take keyword arguments for setting plugs and connecting things
	* AddNode( op1 = 10, op2 = 20 )
* can implement **kwargs in boost python using the undocumented class_.def_raw method

ui
==

* no menu bar?
	* waste of space
	* context sensitive menus should do
		* really? what is the context for file->open?
			* an empty graph window?
	
* fullscreen mode

* CompoundPlugWidget or GroupPlugWidget or whatever
	* String in label to summarise the state of the contents
		* Customisable with a callback function

* consistency!!!
	* hotkeys + modifiers behave similarly everywhere
	* right click is context sensitive menu
	* ctrl-right click is context sensitive menu to modify the ui
	* middle mouse don't do nuffink
		* cos scroll wheels aren't very clickable
		* maybe the scroll wheel can be used for stuff though

* file path control
	* tab completion
	* ctrl delete removes one path level
	* right click on a path component pops up all other options at that level
		* have submenus based on alphabetic ranges when there are too many options
		  at a level
		* selecting an option changes that component
			* but attempts to keep the following components the same if they exist
				* so you can change to the same directory in a different shot

* float/int control
	* no wasting of space with the rubbish +- buttons on the right
		* up/down cursors increment/decrement the digit to the right of the cursor
	* virtual slider?
	
issues
======

plugs/parameters

	- plug has :
		- connections
		- dependencies?
		- signals
		- connectionValid() method
		
	- wrap parameters in a ParameterPlug?

nodes

	- nodes have :
	
		parent (another node)
		children
		compute
		signals

object naming / identification

	- all objects must have a (unique? - not necessarily - could be useful to have groups) id
	- use for selection, grouping, shader application etc
	- need integers for image based selection?
		- yes. id should be integer.
	- is id a "user:gaffer:id" attribute or a primvar?
		- an attribute. then ids can easily be applied to groups and procedurals.
		- we need Renderer::getAttr to work then.
			- RxAttribute does work for user attributes though
	
time

	- we'd like feedback for non-photoreal shit
	- we'd like dependencies at different times for shadow map generation

proxies

	- should be able to use low res standins but still have shaders work,
		deformers work etc.	

procedurals

	- everything should be a procedural?
	
	- procedurals should be able to operate on procedurals
		- this is where the SceneRenderer comes in
			- not necessarily
				- we could have a GafferProcedural base
					class with a build() method which must return a
					VisibleRenderable, and which is called by doRender()
	  
	- how to determine bounds quickly for deformers and transform caches?
	
viewer
======

gl layer with hardware shading and shadowing

final render layer

	- with fast tweaking based on secondary output munging
		- possibly without even raising a tweaker window
			- just drag on the image with hotkeys to make a virtual
			  diffuse/spec/whatever slider for the object under the mouse
	- click raises shader editor for object
		- using id pass

norman lighting layer?

lights
======

* basic point, distant, spot and environment bases
* pluggable light components to modify those lights
	* shadows (manipulator for framing etc)
		* light can have many shadows
	* falloff
	* blockers
	* gobos
	* specular reflection card for spotlight
* reflection cards
* a light component may be connected to any number of lights
* how do we do map generation??

features
========

save all shader parameters with each rendered image
	
	- revert
	- mix back
	
parameter value overlays on saved images?

colorspace management
=====================

* need unified colorspace support everywhere

	-	gtk representations of color
	-	gl representations of color
		-	imager shader? append code onto other shaders as they're compiled?
	-	image transforms
	
* implement as cube luts? then can work anywhere easily

geometry support
================

* polys/subdees
	* done already
* nurbs
	* need IECoreMaya export support
* curves
	* need IECore and IECoreMaya support
* spheres, disks etc
	* need IECore support
* blobbies
	* need IECore support
* hierarchical subdees
	* hold off for the moment

basic timeline
==============

stage one :

signals
nodes/plugs
graph ui
tweaker ui
script editor ui
read node
renderer node
viewer node
write node

stage two :

lights
manipulators
deformers (vertcache)
image based id selection
scenes/transforms
shader assignment
shadow map generation
primvars/per object shader tweaks
expressions
shader library

stage three :

hardware shaders
light linking
trace sets
pointcloud generation (within graph)

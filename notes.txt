
undo/redo
=========

* would be beautiful to see every action taken using the ui go through the script editor.
	* regardless of how we implement undo
* this single point of execution could then implement the undo layer too. is probably pretty doable to make an execution context
(a locals dictionary) that gives exactly the same api as the bindings but implements everything with an undo stack
behind the scenes. this would be awesome - scripts could run with or without undo just by giving them different
contexts.
	* or we implement that in the standard bindings
		* but then you can't write c++ stuff which is undoable
* interactive dragging (slider/manipulators) probably doesn't enter an undoable action for every substep, but just
an undoable event on release?
* we need to batch a series of events into a single undo action (e.g. the results of a script execution)
* either that or we implement undo as a core part of the api anyway  - setValue, setInput, rename, addChild etc
all take some undoContext that they place undo/redo commands into
	* they probably find the undo context by finding their parent script node
		* they shouldn't be passed the undo context, as different actions can't
		  be put into different undo contexts - it would cause havoc
		* which is where the undo context is?
			* or is there one undo context for everything?
				* how do you reparent nodes into one script from another?
					* can't undo in one script but not the other
						* maybe can't move node from one script to another?
	* is undo way easier to implement in python though?
* is it possible to have a singleton undo list, and undo just bits of it nonlinearly?
	* 0 1 2 3 4 5	* undo 1 undoes 54321 and redoes 2345
					* as long as each action has refcounted pointers to the things it operates on this should work?
						* do we even need to unwind and rewind?
							* each undo element will have refcounted pointers to what it needs anyway
								* so even if the objects involved are deleted it'll do the right thing?
									* not really - you could end up connecting things back up to objects which are
									  conceptually deleted. which is an interesting point - how do we delete nodes?
									  	* i thought we could just unparent them, but that's not enough because they'll
										  remain in the undo queue, so connections and wotnot won't be broken
											* we could have del node.child implemented with a __delattr__ method
											  which performs the appropriate disconnections
					
	* if we can do this then :
		* ctrl-z undoes the last action from the global list
		* shift-ctrl-z undoes the last action local to a particular control

cut + paste
===========

* serialise and read
		
script node
===========

* filename plug
* execute( string pythonCode, bool undoable ) method
	* this is what all ui controls use to perform their work, and this is where the undo queue is
	implemented
* undo(), redo() methods
* save/load methods

extendd node constructors
=========================

* take keyword arguments for setting plugs and connecting things
	* AddNode( op1 = 10, op2 = 20 )
* can implement **kwargs in boost python using the undocumented class_.def_raw method

ui
==

* no menu bar?
	* waste of space
	* context sensitive menus should do
		* really? what is the context for file->open?
			* an empty graph window?
	
* fullscreen mode

* consistency!!!
	* hotkeys + modifiers behave similarly everywhere
	* right click is context sensitive menu
	* ctrl-right click is context sensitive menu to modify the ui
	* middle mouse don't do nuffink
		* cos scroll wheels aren't very clickable
		* maybe the scroll wheel can be used for stuff though

* file path control
	* tab completion
	* ctrl delete removes one path level
	* right click on a path component pops up all other options at that level
		* have submenus based on alphabetic ranges when there are too many options
		  at a level
		* selecting an option changes that component
			* but attempts to keep the following components the same if they exist
				* so you can change to the same directory in a different shot

* float/int control
	* no wasting of space with the rubbish +- buttons on the right
		* up/down cursors increment/decrement the digit to the right of the cursor
	* virtual slider?
	
issues
======

plugs/parameters

	- plug has :
		- connections
		- dependencies?
		- signals
		- connectionValid() method
		
	- wrap parameters in a ParameterPlug?

nodes

	- nodes have :
	
		parent (another node)
		children
		compute
		signals

object naming / identification

	- all objects must have a (unique? - not necessarily - could be useful to have groups) id
	- use for selection, grouping, shader application etc
	- need integers for image based selection?
		- yes. id should be integer.
	- is id a "user:gaffer:id" attribute or a primvar?
		- an attribute. then ids can easily be applied to groups and procedurals.
		- we need Renderer::getAttr to work then.
			- RxAttribute does work for user attributes though
	
time

	- we'd like feedback for non-photoreal shit
	- we'd like dependencies at different times for shadow map generation

proxies

	- should be able to use low res standins but still have shaders work,
		deformers work etc.	

procedurals

	- everything should be a procedural?
	
	- procedurals should be able to operate on procedurals
		- this is where the SceneRenderer comes in
			- not necessarily
				- we could have a GafferProcedural base
					class with a build() method which must return a
					VisibleRenderable, and which is called by doRender()
	  
	- how to determine bounds quickly for deformers and transform caches?
	
undo

	- how/where do we implement this?
		- what needs to be undoable
			- create/delete of nodes
			- parent/unparent of nodes
			- add/remove of dynamic plugs
			- set/connect of plugs
			- renaming of nodes and plugs
		- where undo needs to work from
			- node tweaker
			- graph editor
			- script editor?
				- trickier

viewer
======

gl layer with hardware shading and shadowing

final render layer

	- with fast tweaking based on secondary output munging
	- click raises shader editor for object
		- using id pass

norman lighting layer?

features
========

save all shader parameters with each rendered image
	
	- revert
	- mix back
	
parameter value overlays on saved images?

basic timeline
==============

stage one :

signals
nodes/plugs
graph ui
tweaker ui
script editor ui
read node
renderer node
viewer node
write node

stage two :

lights
manipulators
deformers (vertcache)
image based id selection
scenes/transforms
shader assignment
shadow map generation
primvars/per object shader tweaks
expressions
shader library

stage three :

hardware shaders
light linking
trace sets
pointcloud generation (within graph)

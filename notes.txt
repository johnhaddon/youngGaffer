the naming problem :
====================

node["childNode"] = blah

	*	no name clashes
	*	not that pretty
	* 	syntax doesn't match blah.fullName()
	*	does an implicit setName()
		*	has to remove existing children of the same name
	
node.childNode = blah

	*	can't have child nodes with names matching method names
	*	pretty though
	*	and matches blah.fullName()
	*	does an implicit setName()
		*	has to remove existing children of the same name
	* gives us the syntax we want in the script editor
	
or blah.setName( "childNode" ); node.addChild( "blah" )

	* non ambiguous
	* ugly
	* verbose
	* node.addChild may rename child

* is implicit setName() bad?
* is name change on addChild() bad?
* should orphans have no name?
* is there a bug where setName() can be used to make a non-unique name?
* whatever syntax we use we can have a node.childNode syntax in python by making special access objects
	-	like the one we need to make anyway to allow undo/redo

undo/redo
=========

* would be beautiful to see every action taken using the ui go through the script editor.
	* regardless of how we implement undo
* this single point of execution could then implement the undo layer too. is probably pretty doable to make an execution context
(a locals dictionary) that gives exactly the same api as the bindings but implements everything with an undo stack
behind the scenes. this would be awesome - scripts could run with or without undo just by giving them different
contexts.
* interactive dragging (slider/manipulators) probably doesn't enter an undoable action for every substep, but just
an undoable event on release?
* we need to batch a series of events into a single undo action (e.g. the results of a script execution)
* either that or we implement undo as a core part of the api anyway  - setValue, setInput, rename, addChild etc
all take some undoContext that they place undo/redo commands into

ui controls
===========

* consistency!!!
	* hotkeys + modifiers behave similarly everywhere
	* right click is context sensitive menu
	* ctrl-right click is context sensitive menu to modify the ui

* file path control
	* tab completion
	* ctrl delete removes one path level
	* right click on a path component pops up all other options at that level
		* selecting an option changes that component
			* but attempts to keep the following components the same if they exist
				* so you can change to the same directory in a different shot

* float/int control
	* no wasting of space with the rubbish +- buttons on the right
		* up/down cursors increment/decrement the digit to the right of the cursor
	* virtual slider?
	
issues
======

plugs/parameters

	- plug has :
		- connections
		- dependencies?
		- signals
		- connectionValid() method
		
	- wrap parameters in a ParameterPlug?

nodes

	- nodes have :
	
		parent (another node)
		children
		compute
		signals

object naming / identification

	- all objects must have a (unique? - not necessarily - could be useful to have groups) id
	- use for selection, grouping, shader application etc
	- need integers for image based selection?
		- yes. id should be integer.
	- is id a "user:gaffer:id" attribute or a primvar?
		- an attribute. then ids can easily be applied to groups and procedurals.
		- we need Renderer::getAttr to work then.
			- RxAttribute does work for user attributes though
	
time

	- we'd like feedback for non-photoreal shit
	- we'd like dependencies at different times for shadow map generation

proxies

	- should be able to use low res standins but still have shaders work,
		deformers work etc.	

procedurals

	- everything should be a procedural?
	
	- procedurals should be able to operate on procedurals
		- this is where the SceneRenderer comes in
			- not necessarily
				- we could have a GafferProcedural base
					class with a build() method which must return a
					VisibleRenderable, and which is called by doRender()
	  
	- how to determine bounds quickly for deformers and transform caches?
	
undo

	- how/where do we implement this?
		- what needs to be undoable
			- create/delete of nodes
			- parent/unparent of nodes
			- add/remove of dynamic plugs
			- set/connect of plugs
			- renaming of nodes and plugs
		- where undo needs to work from
			- node tweaker
			- graph editor
			- script editor?
				- trickier

viewer
======

gl layer with hardware shading and shadowing

final render layer

	- with fast tweaking based on secondary output munging
	- click raises shader editor for object
		- using id pass

norman lighting layer?

features
========

save all shader parameters with each rendered image
	
	- revert
	- mix back
	
parameter value overlays on saved images?

basic timeline
==============

stage one :

signals
nodes/plugs
graph ui
tweaker ui
script editor ui
read node
renderer node
viewer node
write node

stage two :

lights
manipulators
deformers (vertcache)
image based id selection
scenes/transforms
shader assignment
shadow map generation
primvars/per object shader tweaks
expressions
shader library

stage three :

hardware shaders
light linking
trace sets
pointcloud generation (within graph)
